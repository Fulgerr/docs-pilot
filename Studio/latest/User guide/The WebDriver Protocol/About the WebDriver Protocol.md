# About the WebDriver Protocol

The WebDriver is a popular protocol used to automate browsers. It exposes a REST API in a separate executable than the browser itself. This protocol is widely used with actions such as starting browsers (headless or not), click elements, type into fields, open tabs, explore document object models (DOM), inject Javascript, and more.

In the UiPath Platform, the WebDriver protocol introduces support for headless browser automations. This means that browser automations don't necessarily have to rely on visual elements on screen, such as window frames. Automations are executed in the background, without you having to keep up the browser window. Nonetheless, the WebDriver protocol is not strictly meant for headless browser automations, and can also be used to operate browsers visually.

Automation projects with the WebDriver protocol can be created for the following browsers:

* Google Chrome
* Mozilla Firefox
* Microsoft Edge Browser

Automations via the WebDriver protocol do not require you to install the corresponding browser extensions, but they do require the corresponding browser webdriver executable.

Although the WebDriver protocol can be used for both headless and visual browser automations, it is not meant to replace the UiPath browser extensions, giving you the freedom to use whichever option suits you best.

Selectors generated by the WebDriver protocol are the same as those generated by the UiPath browser extensions. This applies for both headless and visual browser automations, but not to window frames.

The WebDriver opens a new browser session (process) every time, which is independent of any other browser session. When the browser is closed, the corresponding webdriver application (ChromeDriver.exe, geckodriver.exe, or msedgedriver.exe) is also terminated along with all the associated browser sessions.

Automations created with the WebDriver protocol are able to execute browser activities inside and outside of Open Browser containers, and this applies for both headless and visual browser automations. Moreover, native selectors are generated with full interactive selection support for visual browser automations.
